import { Env } from "./types";
import * as jose from "jose";
import { v5 as uuidv5 } from "uuid";

export interface OpenIdConfiguration {
  issuer: string;
  authorization_endpoint: string;
  jwks_uri: string;
  token_endpoint: string;
  userinfo_endpoint: string;
  end_session_endpoint: string;
  scopes_supported: string[];
  response_types_supported: string[];
  token_endpoint_auth_methods_supported: string[];
}

interface UserData {
  firstName: string;
  lastName: string;
  email: string;
}

export async function generatePEM(): Promise<string> {
  // Use jose library to generate a key that can be exported as JWK
  const { privateKey } = await jose.generateKeyPair("RS256", {
    extractable: true,
  });

  // Export as PKCS8 PEM
  const pem = await jose.exportPKCS8(privateKey);
  return pem;
}

export async function ensurePEM(env: Env): Promise<string> {
  await env.DB.prepare(
    `
    CREATE TABLE IF NOT EXISTS local_oidc_secrets (
      id INTEGER PRIMARY KEY,
      pem TEXT NOT NULL,
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      autogenerated BOOLEAN DEFAULT FALSE
    )
  `
  ).run();

  if (env.LOCAL_OIDC_PEM) {
    // If the environment variable exists, it always wins
    // Set it into the database (in case it's missing or changed)
    // and then return the PEM
    const result = await env.DB.prepare(
      `
      INSERT INTO local_oidc_secrets (id, pem, autogenerated, created_at)
      VALUES (1, ?, FALSE, CURRENT_TIMESTAMP)
      ON CONFLICT(id) DO UPDATE SET
        autogenerated = FALSE,
        pem = ?
      RETURNING pem
    `
    )
      .bind(env.LOCAL_OIDC_PEM, env.LOCAL_OIDC_PEM)
      .first<{ pem: string }>();

    return result!.pem;
  } else {
    // The admin didn't provide a PEM. To handle bootstrapping, we'll insert a new
    // one into the database. This new PEM will be used until the admin sets the environment variable
    // Creating a private key is expensive, so we want to check if this has already been done.
    // First, query the database and return an existing PEM. Otherwise, upsert a new one and return it
    const existing = await env.DB.prepare(
      `
      SELECT pem FROM local_oidc_secrets WHERE id = 1
    `
    ).first<{ pem: string }>();

    if (existing) {
      return existing.pem;
    }

    const privateKey = await generatePEM();

    const result = await env.DB.prepare(
      `
      INSERT INTO local_oidc_secrets (id, pem, autogenerated, created_at)
      VALUES (1, ?, TRUE, CURRENT_TIMESTAMP)
      ON CONFLICT(id) DO NOTHING
      RETURNING pem
    `
    )
      .bind(privateKey)
      .first<{ pem: string }>();

    if (!result) {
      // If there was a conflict, then nothing is returned, so we need to query again
      const existing = await env.DB.prepare(
        `
        SELECT pem FROM local_oidc_secrets WHERE id = 1
      `
      ).first<{ pem: string }>();
      return existing!.pem;
    }

    return result.pem;
  }
}

function getBaseUrl(request: Request): string {
  const url = new URL(request.url);
  return `${url.protocol}//${url.host}`;
}

function generateOpenIdConfiguration(
  baseUrl: string,
  env: Env
): OpenIdConfiguration {
  return {
    issuer: `${baseUrl}/local_oidc`,
    authorization_endpoint:
      env.LOCAL_OIDC_AUTHORIZATION_ENDPOINT ??
      "http://localhost:5173/local_oidc/authorize",
    jwks_uri: `${baseUrl}/local_oidc/.well-known/jwks.json`,
    token_endpoint: `${baseUrl}/local_oidc/token`,
    userinfo_endpoint: `${baseUrl}/local_oidc/userinfo`,
    end_session_endpoint: `${baseUrl}/local_oidc/logout`,
    scopes_supported: ["profile", "email", "openid"],
    response_types_supported: ["code"],
    token_endpoint_auth_methods_supported: ["client_secret_post"],
  };
}

async function handleOpenIdConfiguration(
  request: Request,
  env: Env
): Promise<Response> {
  const baseUrl = getBaseUrl(request);
  const config = generateOpenIdConfiguration(baseUrl, env);

  return new Response(JSON.stringify(config, null, 2), {
    status: 200,
    headers: {
      "Content-Type": "application/json",
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Methods": "GET, OPTIONS",
      "Access-Control-Allow-Headers": "Content-Type",
    },
  });
}

function getUserId(userData: UserData): string {
  // Create a deterministic UUID using v5 with null namespace (all zeros)
  const nullNamespace = "00000000-0000-0000-0000-000000000000";

  // Concatenate user data fields in a specific order (not using JSON.stringify)
  const userString = `${userData.firstName}${userData.lastName}${userData.email}`;

  return uuidv5(userString, nullNamespace);
}

async function handleToken(request: Request, env: Env): Promise<Response> {
  // Parse form data instead of URL search params
  const formData = await request.formData();
  const clientId = formData.get("client_id") as string;
  const redirectUri = formData.get("redirect_uri") as string;
  const code = formData.get("code") as string;
  const grantType = formData.get("grant_type") as string;

  console.log("formData", formData);

  if (clientId !== "local-anode-client") {
    console.log("Invalid client_id", clientId);
    return new Response("Invalid client_id", { status: 400 });
  }

  if (!redirectUri || !redirectUri.startsWith("http://localhost")) {
    console.log("Invalid redirect_uri", redirectUri);
    return new Response("Invalid redirect_uri", { status: 400 });
  }

  if (grantType !== "authorization_code") {
    console.log("Invalid grant_type", grantType);
    return new Response("Invalid grant_type", { status: 400 });
  }

  if (!code) {
    console.log("Missing code parameter", code);
    return new Response("Missing code parameter", { status: 400 });
  }

  let userData: UserData;
  try {
    const decodedCode = atob(code);
    userData = JSON.parse(decodedCode) as UserData;

    if (!userData.firstName || !userData.lastName || !userData.email) {
      console.log("Invalid code: missing required fields", userData);
      return new Response("Invalid code: missing required fields", {
        status: 400,
      });
    }
  } catch {
    console.log("Invalid code: not a valid BASE64 encoded JSON", code);
    return new Response("Invalid code: not a valid BASE64 encoded JSON", {
      status: 400,
    });
  }

  try {
    const pem = await ensurePEM(env);
    const privateKey = await jose.importPKCS8(pem, "RS256");
    const baseUrl = getBaseUrl(request);
    const issuer = `${baseUrl}/local_oidc`;
    const userId = getUserId(userData);
    const now = Math.floor(Date.now() / 1000);

    const basePayload = {
      sub: userId,
      given_name: userData.firstName,
      family_name: userData.lastName,
      email: userData.email,
      iss: issuer,
      aud: "local-anode-client",
      iat: now,
    };

    const accessTokenPayload = {
      ...basePayload,
      exp: now + 5 * 60, // 5 minutes
    };

    const refreshTokenPayload = {
      ...basePayload,
      exp: now + 365 * 24 * 60 * 60, // 1 year
    };

    const accessToken = await new jose.SignJWT(accessTokenPayload)
      .setProtectedHeader({ alg: "RS256", kid: "1" })
      .sign(privateKey);

    const refreshToken = await new jose.SignJWT(refreshTokenPayload)
      .setProtectedHeader({ alg: "RS256", kid: "1" })
      .sign(privateKey);

    const payload = {
      access_token: accessToken,
      token_type: "Bearer",
      expires_in: 300,
      refresh_token: refreshToken,
      id_token: accessToken,
      scope: "openid profile email",
    };

    return new Response(JSON.stringify(payload), {
      status: 200,
      headers: {
        "Content-Type": "application/json",
      },
    });
  } catch (error) {
    console.error("Error creating tokens:", error);
    return new Response("Internal Server Error", { status: 500 });
  }
}

interface JWK {
  kty: string;
  use: string;
  kid: string;
  n: string;
  e: string;
}

interface JWKS {
  keys: JWK[];
}

async function handleJwks(_request: Request, env: Env): Promise<Response> {
  try {
    const pem = await ensurePEM(env);
    const privateKey = await jose.importPKCS8(pem, "RS256", {
      extractable: true,
    });

    const publicKey = await jose.exportJWK(privateKey);

    const jwk: JWK = {
      kty: publicKey.kty!,
      use: "sig",
      kid: "1",
      n: publicKey.n!,
      e: publicKey.e!,
    };

    const jwks: JWKS = {
      keys: [jwk],
    };

    return new Response(JSON.stringify(jwks, null, 2), {
      status: 200,
      headers: {
        "Content-Type": "application/json",
        "Access-Control-Allow-Origin": "*",
        "Access-Control-Allow-Methods": "GET, OPTIONS",
        "Access-Control-Allow-Headers": "Content-Type",
      },
    });
  } catch (error) {
    console.error("Error generating JWKS:", error);
    return new Response("Internal Server Error", { status: 500 });
  }
}

export async function handleOidcRequest(
  request: Request,
  env: Env
): Promise<Response> {
  const url = new URL(request.url);
  const pathname = url.pathname;

  if (request.method === "OPTIONS") {
    return new Response(null, {
      status: 200,
      headers: {
        "Access-Control-Allow-Origin": "*",
        "Access-Control-Allow-Methods": "GET, POST, OPTIONS",
        "Access-Control-Allow-Headers": "Content-Type, Authorization",
      },
    });
  }

  if (pathname === "/local_oidc/.well-known/openid-configuration") {
    return handleOpenIdConfiguration(request, env);
  }

  if (pathname === "/local_oidc/.well-known/jwks.json") {
    return handleJwks(request, env);
  }

  if (pathname === "/local_oidc/token") {
    return handleToken(request, env);
  }

  return new Response("Not Found", { status: 404 });
}
